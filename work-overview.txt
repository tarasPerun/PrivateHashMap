1. Чи допрацювали ви контейнери попереднього тижня?

   В моїх колекціях минулого тижня вже буди реалізовані ітератори, так що зміни мінімальні, вони стосуються
   тільки стилю коду і коментарів. Натомість більш суттєво змінені тести колекцій минулого тижня, в них
   додані стрес-тести, тобто такі, в яких вхідні дані завідомо повинні привести до Exception.



2. З якими труднощами зіткнулися при перекладі своїх проектів на свої колекції?

   Особливих труднощів не було, в декількох випадках довелося трохи спростити код, побудову дерева Хафмана
   перевів на пріоритетну чергу, так виявилось набагато простіше, ніж використання зв'язного списку із
   наступним сортуванням.


3. Наскільки просіла продуктивність від переходу?

   Calculator -  для тестування була взята наступна формула:
                 "(1 + 23 / 4 ^ 5 + (-67 / ( cos (8) ^ 9 + sin(tan(atan(log2(10) ^ 11) / 12) + 13)+ 14 - 15 + 16)) ^
                 17 - 18 + (-19 ^ (-20)) * (-21) + 22 ^ 23 + tan(24) - sqrt(25) - 26 + 27 ^ 28 / 29 - 30) / 31 ^a +
                 sqrt(sqrt(625))" "a=36".
                 Час роботи виріс в 1.05 раза, з 2115 мс до 2221 мс.

   Silhouettes - розпізнавання силуетів на основі jpg файлу розміром 1400х980 пікселів - в 2.19 рази. Час роботи
                 програми виріс з 6623 мс до 14551 мс.

   Huffman -     архівування в 1.11 рази, розархівування в 1.05 разів ( по результатах обробки текстового файлу
                 розміром 1.2 Мб, час архівування при переході на власні колекції виріс з 508 мс до 562 мс,
                 розархівування - з 787 мс до 827 мс).

                 Час роботи програм обчислювався як середньоарифметичний
                 із 10 запусків.


4. Яким алгоритмом реалізували PriorityQueue?

   Моя пріоритетна черга реалізована з використанням бінарної купи(піраміди). Алгоритм виявився елегантним і
   зовсім не складним, коли досить складна на перший погляд структура даних зводиться до звичайного масиву.


5. Як ви боретеся з колізіями в HashMap?

   Для обчислення індексів масиву використана відома формула на простих числах. При потраплянні в комірку із вже
   існуючим індексом наступна нода стає наступним елементом зв'язного списку. При перевищенні певного ступеня заповненості
   масиву нодами розмір масиву збільшується в два рази із наступним переформатуванням його і заповненням нодами
   із попереднього масиву з врахуванням зміни індексів комірок.


6. Чи тягне ваша робота на 5?

   За формальними ознаками, тобто відповідності умовам завдання ( підтримці дженеріків, підтримці ітераторів,
   наявності детальних тестів, реалізації пріоритетної черги на binary heap) - так, тягне.
   За внутрішніми відчуттями і потенціальною можливістю покращення - ні, не тягне, є багато можливостей для
   покращення роботи, наприклад, попрацювати над кращою хеш-функцією для мінімізації колізій в HashMap.
